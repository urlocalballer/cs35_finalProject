import numpy as np
import scipy.special

class Nnet:

    def __init__(self, num_input, num_hidden, num_output):
        self.num_input = num_input #Number of input nodes, which is a spread of data over various axes
        self.num_hidden = num_hidden #number of hidden nodes, where each node represents a function attempting to classify data
        self.num_output = num_output #number of outputs, which is a spread of the data when compared to the function generated by the hidden nodes
        self.weight_input_hidden = np.random.uniform(-0.5, 0.5, size=(self.num_hidden, self.num_input)) #remember we will make this -1 to 1
        self.weight_hidden_output = np.random.uniform(-0.5, 0.5, size=(self.num_output, self.num_hidden)) #remember we will make this -1 to 1
        self.activation_function = lambda x: scipy.special.expit(x)

    def get_outputs(self, inputs_list):
        inputs = np.array(inputs_list, ndmin=2).T #Transposing it so the math works
        hidden_inputs = np.dot(self.weight_input_hidden, inputs) #weighting
        hidden_outputs = self.activation_function(hidden_inputs) #applying
        final_inputs = np.dot(self.weight_hidden_output, hidden_outputs) #weighting
        final_outputs = self.activation_function(final_inputs) #applying
        return final_outputs #returning

    def get_max_value(self, inputs_list):
        outputs = self.get_outputs(inputs_list)
        return np.max(outputs) 


























































